## 一起talk C栗子吧（第三十一回：C语言实例--常用排序算法总结）

各位看官们，大家好，上一回中咱们说的是快速排序的例子，这一回咱们不说例子了，咱们把前面说过的排序进行总结。闲话休提，言归正转。让我们一起talk C栗子吧！ 

看官们，我们在前几回说了常用的各种排序算法，它们各有各的特点，我在这里做统一的总结：

容易理解的排序算法是冒泡排序，而且也容易实现，只是性能相对低一些。最难理解的是快速排序，但是
它的性能是最好的。插入排序和选择排序在易理解方面，和性能方面，介于冒泡排序和希尔排序之间。希
尔排序是插入排序的升级版，理解了插入排序后，就不难去理解希尔排序。而且希尔排序的性能比插入排
序高，不过比快速排序要低。

我在上面说的性能只是相对来说的，每种排序算法在特定的条件下才能发挥出它的性能优势来。我们说某
种排序算法性能高，是一个平均值。比如我们在前几回举过的例子中，容器中元素的数量都为10，这时候
对比性能最差的冒泡排序和性能最好的快速排序后，我们可以发现，它们的执行时间相同，待会给大家看
例子。这时候因为容器中元素数量小，所以体现不出快速排序的优势来。因此，大家在工作中，可以依据
实际的情况来选择不同的排序算法，如果不注重性能，那么选择一个容易实现的排序算法就可以，这样写
出来的程序也方便阅读。如果排序的内容不多，使用中等性能的希尔排序是个不错的选择，如果排序的内
容多，那么最好使用性能高的快速排序。

看官们，下面是我在Linux终端中使用time命令测试后的结果，供大家参考。大家可以修改容器中元素的数量，自己来测试各个排序算法的性能。

```
time ./BubbleSort  //冒泡排序的时间
the elmt of array is : 
 70 27 52 96 38 83 35 0 85 50  
after sort, the elmt of array is : 
 0 27 35 38 50 52 70 83 85 96  

real	0m0.002s
user	0m0.000s
sys	0m0.000s

time ./QuickSort  //快速排序的时间
the elmt of array is : 
 36 73 41 0 37 21 94 91 26 98  
after sort, the elmt of array is : 
 0 21 26 36 37 41 73 91 94 98  

real	0m0.002s
user	0m0.000s
sys	0m0.000s
```

各位看官，关于排序的总结咱们就说到这里。欲知后面还有什么例子，且听下回分解。
